<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guardian Pro CCTV System Simulator | V8 Wide Designer</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font and warm dark theme styling */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a0f0f; /* Very deep dark red/brown base */
            color: #fce7d0; /* Soft warm light text */
            min-height: 100vh;
        }
        
        .main-card {
            background-color: #2b1a1a; /* Slightly lighter deep red/brown */
            border: 1px solid #5a3c3c; /* Darker warm border */
        }

        #simulatorCanvas {
            border: 1px solid #5a3c3c;
            background-color: #1a0f0f; /* Canvas matches body background for seamless look */
            width: 100%;
            height: 450px; /* Default height for mobile/tablet */
            cursor: default;
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.4); /* Glowing orange effect */
            transition: box-shadow 0.3s;
        }
        
        /* New expansive canvas styling for desktop */
        @media (min-width: 1024px) {
            #simulatorCanvas {
                height: 80vh; /* Takes 80% of the viewport height */
            }
        }
        
        .panel-section {
            background-color: #2b1a1a; 
            border: 1px solid #5a3c3c;
        }

        /* Warm Button Style */
        .action-btn {
            @apply p-3 rounded-lg font-semibold transition duration-200 transform hover:scale-[1.02] active:scale-[0.98] shadow-lg;
        }

        /* Input/Select Styling */
        input, select {
            @apply bg-zinc-800 border-zinc-700 text-amber-50 rounded-md focus:border-orange-500 focus:ring-orange-500 placeholder-zinc-500;
        }
    </style>
</head>
<body class="p-4 sm:p-8">

<div class="max-w-7xl mx-auto main-card rounded-xl p-4 md:p-10 shadow-2xl">
    
    <header class="mb-8 text-center lg:text-left">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-orange-400 mb-2">
            GUARDIAN PRO V8 | Blueprint Designer
        </h1>
        <p class="text-lg text-amber-200">
            Advanced planning for a safer environment with an expansive view.
        </p>
    </header>

    
    <!-- GRID LAYOUT: 1/5 for Controls, 4/5 for Canvas on desktop -->
    <div class="grid lg:grid-cols-5 gap-8">

        
        <!-- LEFT SIDEBAR: CONTROLS (1/5 width on desktop, full width on mobile) -->
        <div class="lg:col-span-1 space-y-6">
            <h2 class="text-xl font-bold text-amber-50 border-b border-amber-800 pb-3">
                Control Panel
            </h2>

            
            <div id="auth-status" class="panel-section p-3 rounded-lg text-xs break-all">
                <p class="font-semibold text-orange-400">Loading User ID...</p>
            </div>
            
            
            <div class="panel-section p-4 rounded-lg shadow-inner">
                <h3 class="font-bold text-amber-50 mb-3 text-sm">Blueprint Source</h3>
                
                <label for="map-image-url" class="block text-xs font-medium text-amber-300 mb-1">Image URL</label>
                <input type="text" id="map-image-url" placeholder="Paste URL here" onchange="updateMapUrl(this.value)"
                       class="w-full px-2 py-1 text-xs">
                
                <label for="map-file-upload" class="block text-xs font-medium text-amber-300 mb-1 mt-3">Upload Local File</label>
                <input type="file" id="map-file-upload" accept="image/*" class="w-full px-2 py-1 text-xs border-0 bg-zinc-800 rounded-md">
                
                <button onclick="loadMapImage()" class="action-btn w-full mt-3 bg-orange-600 text-white hover:bg-orange-700 text-sm py-2">
                    Load Blueprint
                </button>
            </div>

            
            <div class="panel-section p-4 rounded-lg shadow-inner">
                <label for="mode-select" class="block text-sm font-medium text-amber-200 mb-2">
                    Placement Tool:
                </label>
                <select id="mode-select" onchange="setMode(this.value)"
                        class="w-full px-2 py-1 text-sm">
                    <option value="camera" selected>üìπ Place Security Camera</option>
                    <option value="door">üö™ Add Entry Point</option>
                    <option value="wall">üß± Draw Structure/Wall</option>
                    <option value="delete">üóëÔ∏è Delete Object</option>
                </select>
            </div>

            
            <div id="camera-settings" class="panel-section p-4 rounded-lg shadow-md border-orange-500/50">
                <h3 class="font-bold text-orange-400 mb-3 text-sm">Camera Specs (Active Tool)</h3>
                
                <div class="mb-3">
                    <label for="focal-length" class="block text-xs font-medium text-amber-300">Lens (mm)</label>
                    <select id="focal-length" onchange="queueSave()"
                            class="w-full px-2 py-1 text-xs">
                        <option value="2.8">2.8 mm (Wide)</option>
                        <option value="4" selected>4 mm (Standard)</option>
                        <option value="6">6 mm (Zoom)</option>
                    </select>
                </div>
                
                <div class="mb-4">
                    <label for="mount-height" class="block text-xs font-medium text-amber-300">Mount Height (Meters)</label>
                    <input type="number" id="mount-height" value="2.5" step="0.5" min="1" oninput="queueSave()"
                           class="w-full px-2 py-1 text-xs">
                </div>

                
                <div class="border-t border-amber-800 pt-3">
                    <p class="text-xs font-medium text-amber-300 mb-2">Rotate Selected Camera:</p>
                    <div class="flex justify-center space-x-3">
                        <button onclick="rotateSelectedCamera(-Math.PI / 12)" 
                                class="action-btn bg-amber-500 text-gray-900 hover:bg-amber-400 px-3 py-1 text-lg">
                            &#x21BA; 
                        </button>
                        <button onclick="rotateSelectedCamera(Math.PI / 12)" 
                                class="action-btn bg-amber-500 text-gray-900 hover:bg-amber-400 px-3 py-1 text-lg">
                            &#x21BB; 
                        </button>
                    </div>
                </div>
            </div>

            
            <div class="space-y-4 pt-2">
                <button onclick="assessDesign()" class="action-btn w-full bg-orange-600 text-white hover:bg-orange-700 text-sm py-2">
                    ANALYSE & GET RECOMMENDATIONS
                </button>
                <button onclick="clearCanvasPrompt()" class="action-btn w-full bg-red-800 text-white hover:bg-red-700 text-sm py-2">
                    Clear Blueprint & Wipe Data
                </button>
            </div>
        </div>

        
        <!-- RIGHT MAIN AREA: CANVAS & LEGEND (4/5 width on desktop) -->
        <div class="lg:col-span-4 flex flex-col h-full">
            <div class="relative bg-gray-200 rounded-xl shadow-inner overflow-hidden flex-grow">
                <canvas id="simulatorCanvas" width="900" height="600"></canvas>
            </div>

            
            <div class="mt-4 p-4 panel-section rounded-lg shadow-md text-sm">
                <h3 class="font-bold mb-2 text-amber-50">Evidence Clarity (DORI Legend):</h3>
                <div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
                    <span class="flex items-center text-red-400"><div class="w-3 h-3 rounded-full mr-2 bg-red-600/50 border border-red-400"></div> Detection (25-59 PPM)</span>
                    <span class="flex items-center text-orange-400"><div class="w-3 h-3 rounded-full mr-2 bg-orange-600/50 border border-orange-400"></div> Observation (60-119 PPM)</span>
                    <span class="flex items-center text-yellow-400"><div class="w-3 h-3 rounded-full mr-2 bg-yellow-600/50 border border-yellow-400"></div> Recognition (120-249 PPM)</span>
                    <span class="flex items-center text-amber-400"><div class="w-3 h-3 rounded-full mr-2 bg-amber-600/50 border border-amber-400"></div> Identification (250+ PPM)</span>
                </div>
            </div>
        </div>
    </div>

    
    <div class="mt-8 p-6 panel-section rounded-xl shadow-lg border-t-2 border-orange-500">
        <p id="message-box" class="text-center font-medium text-amber-300">Initializing system and connecting to cloud database...</p>
    </div>

</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- FIREBASE INITIALIZATION & GLOBALS ---
    setLogLevel('Debug');
    
    let db, auth;
    let userId = null;
    let isAuthReady = false;
    
    // MANDATORY GLOBAL VARIABLES (Provided by Canvas Environment)
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
    // FIX: __initial_auth_token is a JWT string, so it must NOT be parsed as JSON.
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 


    // Canvas & Context Setup
    const CANVAS = document.getElementById('simulatorCanvas');
    const CTX = CANVAS.getContext('2d');
    const SCALING_FACTOR_PIXELS_PER_METER = 50; 
    const SENSOR_WIDTH_MM = 5.37;
    const DORI_THRESHOLDS = {
        IDENTIFICATION: 250, 
        RECOGNITION: 120, 
        OBSERVATION: 60, 
        DETECTION: 25 
    };
    
    // State Management
    let currentState = {
        mode: 'camera',
        objects: [], 
        mapImageUrl: '',
        isDrawing: false,
        selectedObject: null,
    };
    let backgroundMapImage = null; // HTML Image object
    let draggedObject = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    
    // Saving Queue to prevent excessive writes
    let saveTimeout = null;

    // --- FIREBASE HELPER FUNCTIONS ---

    function getDesignRef() {
        if (!db || !userId) return null;
        return doc(db, 
            'artifacts', appId, 
            'users', userId, 
            'designs', 'master_design'
        );
    }
    
    /**
     * Saves the current application state (objects and map URL) to Firestore.
     */
    async function saveDesign() {
        if (!isAuthReady || !userId) {
            console.warn("Attempted save before auth ready.");
            return;
        }

        const designRef = getDesignRef();
        if (!designRef) return;

        try {
            await setDoc(designRef, { 
                objects: currentState.objects,
                mapImageUrl: currentState.mapImageUrl, 
                lastUpdated: new Date().toISOString()
            }, { merge: true });
            
            showMessage('üíæ Design saved to cloud.', 'text-green-400');
        } catch (error) {
            console.error("Firestore Save Error:", error);
            showMessage('‚ùå Failed to save design.', 'text-red-500');
        }
    }

    function queueSave() {
        if (saveTimeout) {
            clearTimeout(saveTimeout);
        }
        saveTimeout = setTimeout(saveDesign, 500); 
    }

    /**
     * Loads the background map image from the stored URL or Data URL.
     */
    window.loadMapImage = function() {
        if (!currentState.mapImageUrl) {
            backgroundMapImage = null;
            drawAll();
            return;
        }

        backgroundMapImage = new Image();
        backgroundMapImage.onload = () => {
            drawAll();
            showMessage('üó∫Ô∏è Blueprint loaded successfully.', 'text-amber-400');
        };
        backgroundMapImage.onerror = () => {
             showMessage('‚ö†Ô∏è Error loading map image. Check URL or CORS. Clearing map.', 'text-red-500');
             backgroundMapImage = null;
             currentState.mapImageUrl = ''; 
             document.getElementById('map-image-url').value = '';
             drawAll();
        };
        backgroundMapImage.src = currentState.mapImageUrl;
    }

    /**
     * Updates the map URL input field and queues a save.
     */
    window.updateMapUrl = function(url) {
        if (url && url.length > 5 && (url.startsWith('http') || url.startsWith('data:'))) {
            currentState.mapImageUrl = url;
            loadMapImage();
            queueSave();
        } else if (!url) {
            currentState.mapImageUrl = '';
            loadMapImage(); 
            queueSave();
        }
    }
    
    /**
     * Handles file selection from the user's computer.
     */
    document.getElementById('map-file-upload').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const dataUrl = e.target.result;
                
                currentState.mapImageUrl = dataUrl;
                document.getElementById('map-image-url').value = '--- Local File Loaded ---';
                loadMapImage();
                queueSave();
                showMessage('üìÅ Local blueprint uploaded and saved.', 'text-green-400');
            };
            reader.onerror = () => {
                 showMessage('‚ùå Failed to read local file.', 'text-red-500');
            };
            reader.readAsDataURL(file); 
        }
    });


    /**
     * Listens for real-time updates to the design document.
     */
    function loadRealTimeDesign() {
        if (!isAuthReady || !userId) {
            console.warn("Attempted onSnapshot before auth ready.");
            return;
        }

        const designRef = getDesignRef();
        if (!designRef) return;

        onSnapshot(designRef, (docSnap) => {
            if (docSnap.exists()) {
                const data = docSnap.data();
                let hasChanged = false;
                
                if (data.objects && JSON.stringify(data.objects) !== JSON.stringify(currentState.objects)) {
                     currentState.objects = data.objects;
                     hasChanged = true;
                }
                
                if (data.mapImageUrl !== currentState.mapImageUrl) {
                    currentState.mapImageUrl = data.mapImageUrl || '';
                    document.getElementById('map-image-url').value = currentState.mapImageUrl.length > 50 ? '--- Saved Data URL Loaded ---' : currentState.mapImageUrl;
                    loadMapImage(); 
                    hasChanged = true;
                }
                
                if (hasChanged) {
                    drawAll();
                    showMessage('‚òÅÔ∏è Design updated from cloud.', 'text-blue-400');
                }
            } else {
                showMessage('Welcome! Starting new blueprint.', 'text-amber-300');
                saveDesign();
            }
        }, (error) => {
            console.error("Firestore Snapshot Error:", error);
            showMessage('‚ùå Real-time connection lost.', 'text-red-500');
        });
    }

    async function initFirebaseAndAuth() {
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            if (initialAuthToken) {
                // Corrected: token is used as a string, not parsed as JSON
                await signInWithCustomToken(auth, initialAuthToken); 
            } else {
                await signInAnonymously(auth);
            }
            
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    isAuthReady = true;
                    
                    document.getElementById('auth-status').innerHTML = `
                        <p class="font-semibold text-orange-400">User ID (Private Save):</p>
                        <p class="text-xs text-amber-300">${userId}</p>
                    `;
                    
                    loadRealTimeDesign();
                } else {
                    isAuthReady = false;
                    document.getElementById('auth-status').innerHTML = '<p class="text-red-500">Authentication Failed.</p>';
                }
            });

        } catch (error) {
            console.error("Firebase Initialization Error:", error);
            showMessage(`Fatal Error: ${error.message}`, 'text-red-500');
        }
    }


    // --- DRAWING AND UI LOGIC ---

    function drawGrid() {
        CTX.strokeStyle = '#d4af37'; // Gold-ish yellow for grid
        CTX.lineWidth = 1;
        for (let y = 0; y < CANVAS.height; y += SCALING_FACTOR_PIXELS_PER_METER) {
            CTX.beginPath(); CTX.moveTo(0, y); CTX.lineTo(CANVAS.width, y); CTX.stroke();
        }
        for (let x = 0; x < CANVAS.width; x += SCALING_FACTOR_PIXELS_PER_METER) {
            CTX.beginPath(); CTX.moveTo(x, 0); CTX.lineTo(x, CANVAS.height); CTX.stroke();
        }
    }

    function calculateCameraFOV(camera) {
        const halfSensorRatio = (SENSOR_WIDTH_MM / 2) / camera.focalLength;
        const hfovRadians = 2 * Math.atan(halfSensorRatio);
        const maxRangeMeters = 15; 
        const maxRangePixels = maxRangeMeters * SCALING_FACTOR_PIXELS_PER_METER;
        const coverageWidth = 2 * maxRangeMeters * Math.tan(hfovRadians / 2);
        const pixelsHorizontal = 2560; 
        const ppmAtMaxRange = pixelsHorizontal / coverageWidth;

        let doriColor = 'rgba(239, 68, 68, 0.15)'; // Red for Detection
        if (ppmAtMaxRange >= DORI_THRESHOLDS.IDENTIFICATION) doriColor = 'rgba(255, 200, 0, 0.25)'; // Bright yellow for Identification
        else if (ppmAtMaxRange >= DORI_THRESHOLDS.RECOGNITION) doriColor = 'rgba(255, 165, 0, 0.25)'; // Orange for Recognition
        else if (ppmAtMaxRange >= DORI_THRESHOLDS.OBSERVATION) doriColor = 'rgba(255, 69, 0, 0.25)'; // Red-Orange for Observation
        
        return { hfovRadians, maxRangePixels, doriColor, ppmAtMaxRange };
    }
    
    function drawCamera(camera) {
        const x = camera.x, y = camera.y, radius = 8;
        const fov = calculateCameraFOV(camera);
        
        // 1. Draw FOV Cone
        CTX.fillStyle = fov.doriColor;
        CTX.beginPath();
        CTX.moveTo(x, y);
        const startAngle = camera.angle - (fov.hfovRadians / 2);
        const endAngle = camera.angle + (fov.hfovRadians / 2);
        const x1 = x + fov.maxRangePixels * Math.cos(startAngle);
        const y1 = y + fov.maxRangePixels * Math.sin(startAngle);
        const x2 = x + fov.maxRangePixels * Math.cos(endAngle);
        const y2 = y + fov.maxRangePixels * Math.sin(endAngle);
        CTX.lineTo(x1, y1); CTX.lineTo(x2, y2); CTX.closePath(); CTX.fill();

        // 2. Draw Camera Icon (CCTV-like shape with warm colors)
        CTX.fillStyle = '#ffb74d'; // Soft orange for body
        CTX.strokeStyle = '#ff8c00'; // Darker orange for outline
        CTX.lineWidth = 2;
        
        // Base dome/body
        CTX.beginPath(); CTX.arc(x, y, radius, 0, 2 * Math.PI); CTX.fill(); CTX.stroke();
        
        // Lens reflection/detail
        CTX.fillStyle = '#3a2b2b'; // Darker lens
        CTX.beginPath(); CTX.arc(x + 2, y - 2, radius * 0.5, 0, 2 * Math.PI); CTX.fill();
        
        // 3. Draw Directional Pointer
        CTX.strokeStyle = '#ffe082'; // Lighter yellow pointer
        CTX.lineWidth = 3;
        CTX.beginPath(); CTX.moveTo(x, y);
        CTX.lineTo(x + radius * 3 * Math.cos(camera.angle), y + radius * 3 * Math.sin(camera.angle));
        CTX.stroke();

        // 4. Draw Label
        CTX.font = '10px Inter'; CTX.fillStyle = '#ffecb3'; // Light yellow text
        CTX.fillText(`${camera.focalLength}mm`, x + 15, y - 5);
        CTX.fillText(`${Math.round(fov.ppmAtMaxRange)} PPM`, x + 15, y + 10);
    }
    
    function drawDoor(door) {
        const size = 15;
        CTX.fillStyle = door.covered ? 'rgba(128, 203, 196, 0.8)' : 'rgba(255, 160, 0, 0.9)'; // Teal for secure, Bright Orange for exposed
        CTX.fillRect(door.x - size / 2, door.y - size / 2, size, size);
        CTX.strokeStyle = '#ff8c00'; CTX.lineWidth = 2; // Dark orange border
        CTX.strokeRect(door.x - size / 2, door.y - size / 2, size, size);
        CTX.font = '8px Inter'; CTX.fillStyle = '#fce7d0'; // Warm light text
        CTX.fillText(door.covered ? "SECURE" : "EXPOSED", door.x - 12, door.y + 20);
    }

    function drawWall(wall) {
        if (!wall.endX) return; 
        CTX.strokeStyle = '#a1887f'; // Warm brown for walls
        CTX.lineWidth = 5;
        CTX.beginPath();
        CTX.moveTo(wall.startX, wall.startY);
        CTX.lineTo(wall.endX, wall.endY);
        CTX.stroke();
    }
    
    function drawAll() {
        CTX.clearRect(0, 0, CANVAS.width, CANVAS.height);
        
        if (backgroundMapImage) {
            CTX.drawImage(backgroundMapImage, 0, 0, CANVAS.width, CANVAS.height);
        } else {
            drawGrid();
        }

        currentState.objects.forEach(obj => {
            switch(obj.type) {
                case 'camera':
                    drawCamera(obj);
                    break;
                case 'door':
                    drawDoor(obj);
                    break;
                case 'wall':
                    drawWall(obj);
                    break;
            }
            if (currentState.selectedObject && currentState.selectedObject.id === obj.id) {
                CTX.strokeStyle = '#ef4444'; // Red highlight for selected
                CTX.lineWidth = 3;
                if (obj.type === 'wall') {
                     CTX.strokeRect(Math.min(obj.startX, obj.endX) - 5, Math.min(obj.startY, obj.endY) - 5, 
                                    Math.abs(obj.endX - obj.startX) + 10, Math.abs(obj.endY - obj.startY) + 10);
                } else {
                    CTX.strokeRect(obj.x - 10, obj.y - 10, 20, 20);
                }
            }
        });
    }
    
    // --- ROTATION LOGIC ---
    
    window.rotateSelectedCamera = function(deltaAngle) {
        if (!currentState.selectedObject || currentState.selectedObject.type !== 'camera') {
            showMessage('Select a camera first to rotate.', 'text-orange-400');
            return;
        }
        currentState.selectedObject.angle += deltaAngle;
        queueSave();
        drawAll();
        showMessage('Camera orientation updated.', 'text-amber-400');
    }
    
    // --- INTERACTION HANDLERS ---

    function getMousePos(event) {
        const rect = CANVAS.getBoundingClientRect();
        let x = event.clientX;
        let y = event.clientY;

        if (event.touches && event.touches.length > 0) {
            x = event.touches[0].clientX;
            y = event.touches[0].clientY;
        }
        
        return { x: x - rect.left, y: y - rect.top };
    }

    function getObjectAtPos(x, y) {
        const tolerance = 25; 
        for (let i = currentState.objects.length - 1; i >= 0; i--) {
            const obj = currentState.objects[i];
            if (obj.type === 'wall') continue; 
            const dx = obj.x - x;
            const dy = obj.y - y;
            if (Math.sqrt(dx * dx + dy * dy) < tolerance) {
                return obj;
            }
        }
        return null;
    }

    CANVAS.addEventListener('mousedown', handlePointerDown);
    CANVAS.addEventListener('touchstart', handlePointerDown);

    function handlePointerDown(event) {
        event.preventDefault(); 
        const pos = getMousePos(event);
        currentState.isDrawing = true;

        draggedObject = getObjectAtPos(pos.x, pos.y);
        
        if (draggedObject) {
            dragOffsetX = pos.x - draggedObject.x;
            dragOffsetY = pos.y - draggedObject.y;
            CANVAS.style.cursor = 'grabbing';
            currentState.selectedObject = draggedObject; 
            drawAll(); 
            return; 
        }

        currentState.selectedObject = null;
        
        if (currentState.mode === 'camera') {
            placeCamera(pos.x, pos.y);
        } else if (currentState.mode === 'door') {
            placeDoor(pos.x, pos.y);
        } else if (currentState.mode === 'wall') {
            startWall(pos.x, pos.y);
        } else if (currentState.mode === 'delete') {
             const objectToDelete = getObjectAtPos(pos.x, pos.y);
             if(objectToDelete) deleteObject(objectToDelete);
        }
        
        drawAll();
    }
    
    CANVAS.addEventListener('mousemove', handlePointerMove);
    CANVAS.addEventListener('touchmove', handlePointerMove);

    function handlePointerMove(event) {
        const pos = getMousePos(event);

        if (draggedObject) {
            event.preventDefault(); 
            draggedObject.x = pos.x - dragOffsetX;
            draggedObject.y = pos.y - dragOffsetY;
            drawAll();
        } else if (currentState.isDrawing) {
            if (currentState.mode === 'wall' && currentState.objects.length > 0) {
                const wall = currentState.objects[currentState.objects.length - 1];
                if (wall.type === 'wall') {
                    wall.endX = pos.x;
                    wall.endY = pos.y;
                }
            }
            drawAll();
        } else {
            const hoverObj = getObjectAtPos(pos.x, pos.y);
            CANVAS.style.cursor = hoverObj ? 'grab' : 'default'; 
        }
    }
    
    CANVAS.addEventListener('mouseup', handlePointerUp);
    CANVAS.addEventListener('touchend', handlePointerUp);

    function handlePointerUp(event) {
        currentState.isDrawing = false;
        
        if (currentState.mode === 'wall' && currentState.objects.length > 0) {
            const wall = currentState.objects[currentState.objects.length - 1];
            if (wall.type === 'wall' && wall.startX === wall.endX && wall.startY === wall.startY) {
                currentState.objects.pop();
            }
        }
        
        if (draggedObject) {
            draggedObject = null;
            queueSave(); 
        }

        CANVAS.style.cursor = 'default';
        queueSave(); 
        drawAll();
    }
    
    CANVAS.addEventListener('contextmenu', (event) => {
        event.preventDefault(); 
        const pos = getMousePos(event);
        const clickedObj = getObjectAtPos(pos.x, pos.y);
        
        if (clickedObj && clickedObj.type === 'camera') {
            currentState.selectedObject = clickedObj;
            rotateSelectedCamera(Math.PI / 12); 
        }
    });


    function setMode(newMode) {
        currentState.mode = newMode;
        if (newMode === 'delete') {
             showMessage('Click on an asset to delete it.', 'text-red-500');
        }
        CANVAS.style.cursor = 'default';
    }
    
    function placeCamera(x, y) {
        const focalLength = parseFloat(document.getElementById('focal-length').value);
        const mountHeight = parseFloat(document.getElementById('mount-height').value);
        
        const newCamera = {
            type: 'camera', id: Date.now(), x: x, y: y, angle: 0, 
            focalLength: focalLength, mountHeight: mountHeight
        };
        currentState.objects.push(newCamera);
        currentState.selectedObject = newCamera; 
        showMessage('Security Camera deployed. Use buttons or right-click to rotate.', 'text-green-400');
    }

    function placeDoor(x, y) {
        currentState.objects.push({
            type: 'door', id: Date.now(), x: x, y: y, covered: false 
        });
        showMessage('Entry Point logged.', 'text-orange-400');
    }
    
    function startWall(x, y) {
        currentState.objects.push({
            type: 'wall', id: Date.now(), startX: x, startY: y, endX: x, endY: y
        });
    }
    
    function deleteObject(obj) {
        if (obj) {
             currentState.objects = currentState.objects.filter(o => o.id !== obj.id);
             currentState.selectedObject = null;
             queueSave();
             drawAll();
             showMessage(`üóëÔ∏è Asset deleted: ${obj.type.toUpperCase()}`, 'text-red-500');
        }
    }
    
    function clearCanvasPrompt() {
        alertUser(`
            <h3 class="text-xl font-bold text-red-500 mb-4">CONFIRM DATA WIPE</h3>
            <p class="text-amber-200">Are you sure you want to clear the entire blueprint? This will also wipe your cloud data for this app.</p>
        `, () => {
            currentState.objects = [];
            currentState.mapImageUrl = '';
            currentState.selectedObject = null;
            document.getElementById('map-image-url').value = '';
            document.getElementById('map-file-upload').value = null; 
            backgroundMapImage = null;
            saveDesign(); 
            drawAll();
            showMessage('Blueprint wiped. System ready for new deployment.', 'text-red-500');
        });
    }

    function showMessage(text, colorClass) {
        const msgBox = document.getElementById('message-box');
        msgBox.textContent = text;
        msgBox.className = `mt-4 text-center font-medium ${colorClass}`;
        if (!text.includes('saved') && !text.includes('updated')) {
             setTimeout(() => { msgBox.textContent = ''; msgBox.className = 'mt-4 text-center font-medium text-amber-300'; }, 5000);
        }
    }
    
    function assessDesign() {
         alertUser(`
            <h3 class="text-2xl font-bold text-orange-400 mb-4">SYSTEM DEPLOYMENT ANALYSIS</h3>
            <p class="text-amber-200">This feature would analyze camera overlaps and DORI coverage. Implementation is pending, but your data is safely saved in the cloud (User ID: ${userId}).</p>
        `, () => {}); 
    }

    // Custom Modal Function (replaces alert/confirm)
    function alertUser(htmlContent, confirmCallback) {
        const modalId = 'custom-simulator-modal';
        let modal = document.getElementById(modalId);
        if (!modal) {
            modal = document.createElement('div');
            modal.id = modalId;
            modal.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 p-4';
            document.body.appendChild(modal);
        }

        modal.innerHTML = `
            <div class="main-card p-8 rounded-xl shadow-2xl max-w-lg w-full border border-orange-500">
                <div class="space-y-4 text-gray-800">${htmlContent}</div>
                <div class="mt-6 flex justify-end space-x-3">
                    <button id="modal-close-btn" class="action-btn bg-zinc-600 text-white px-4 py-2 hover:bg-zinc-700">
                        CLOSE
                    </button>
                    ${confirmCallback.toString().includes("clearCanvasPrompt") ? 
                        `<button id="modal-confirm-btn" class="action-btn bg-red-600 text-white px-4 py-2 hover:bg-red-700">
                            CONFIRM WIPE
                        </button>` : ''}
                </div>
            </div>
        `;
        modal.style.display = 'flex';

        document.getElementById('modal-close-btn').onclick = () => { modal.style.display = 'none'; };
        if (document.getElementById('modal-confirm-btn')) {
            document.getElementById('modal-confirm-btn').onclick = () => {
                confirmCallback();
                modal.style.display = 'none';
            };
        }
    }


    // Initialization
    window.onload = function() {
        // Correctly initialize canvas dimensions
        CANVAS.width = CANVAS.offsetWidth;
        CANVAS.height = CANVAS.offsetHeight; 
        initFirebaseAndAuth();
    };
    
    window.addEventListener('resize', () => {
        // Update canvas dimensions on window resize
        CANVAS.width = CANVAS.offsetWidth;
        CANVAS.height = CANVAS.offsetHeight; 
        drawAll();
    });

</script>
</body>
</html>
